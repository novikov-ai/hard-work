# Избавляемся от зависимости от зависимостей

### 1. Зависимость фреймворка
На одном из проектов я использовал стандартную библиотеку `net/http` для создания веб-сервера. В рамках проекта я регистрировал обработчики запросов в маршрутизаторе, и понял, что сам сервер не зависит от их конкретной логики. Чтобы избежать ситуаций, когда сбой в одном из обработчиков мог бы нарушить работу всего сервера, я решил изолировать обработчики и добавил в них обработку ошибок. Это было осознанным решением для повышения устойчивости сервера.

### 2. Зависимость расшаренного формата
В одном из сервисов я сталкивался с ситуацией, когда мой код взаимодействовал с другим сервисом через JSON API. Понимая, что если структура JSON изменится на одной стороне, другая сторона будет вынуждена адаптироваться, я решил внедрить версионирование API и добавить строгую валидацию входящих данных. Это решение я принял осознанно, чтобы минимизировать влияние изменений формата данных.

### 3. Зависимость зависимости
Однажды я работал над проектом, где использовалась сторонняя библиотека для работы с базой данных. Эта библиотека зависела от пакета для логирования, и однажды изменение в логирующем пакете вызвало ошибки при сборке приложения. Чтобы избежать таких ситуаций в будущем, я решил фиксировать версии всех используемых зависимостей в `go.mod`. Это было осознанным шагом, направленным на предотвращение сбоев, вызванных изменениями в сторонних библиотеках.

### 4. Зависимость краша
В одной из моих систем несколько микросервисов взаимодействовали друг с другом, и я осознал, что сбой одного из микросервисов может вызвать цепную реакцию сбоев в других сервисах. Чтобы минимизировать риски, я внедрил механизмы Circuit Breaker и Graceful Degradation, которые позволили снизить влияние одного сбоя на всю систему. Это решение было осознанным и важным для повышения отказоустойчивости всей системы.

### 5. Зависимость перебрасывания
В одном из проектов я работал над сервисом, который использовал внешнюю API для отправки уведомлений. Понимая, что основной API может быть недоступен, я заранее спланировал и реализовал механизм переключения на резервный API. Это решение позволило поддерживать работоспособность сервиса даже в случае сбоев основного API.

### 6. Зависимость инверсии
При разработке компонента работы с базой данных я использовал интерфейсы и внедрение зависимостей (Dependency Injection). Компонент принимал на вход интерфейс `DBConnector`, что давало мне возможность легко менять реализацию (например, `MySQLConnector` или `PostgresConnector`). Чтобы убедиться в корректности реализации, я написал юнит-тесты для проверки всех возможных вариантов. Это было осознанным решением, которое обеспечило гибкость и тестируемость кода.

### 7. Зависимость зацикливания
Во время работы над одним проектом я столкнулся с циклом зависимости между двумя пакетами `A` и `B`, где `A` импортировал `B`, а `B` импортировал `A`. Это привело к проблемам с компиляцией. Чтобы решить проблему, я рефакторизовал код, выделив общие функции и структуры в отдельный пакет `C`, который стал использоваться как `A`, так и `B`. Это решение было осознанным и помогло улучшить структуру проекта.

### 8. Зависимость высшего порядка
В одном из моих проектов я использовал стандартную библиотеку `container/heap` для работы с приоритетной очередью. Я осознал, что поведение очереди зависит от того, как я реализую интерфейс `heap.Interface` для своих структур данных. Чтобы избежать проблем с некорректной работой, я написал тесты для проверки правильности реализации этого интерфейса. Это был осознанный шаг, чтобы гарантировать корректную работу структуры данных.

### 9. Зависимость большинства
Я участвовал в проекте, где несколько микросервисов должны были взаимодействовать друг с другом для выполнения одной задачи. Понимая, что ошибка в логике одного из микросервисов может повлиять на работу всей системы, я решил внедрить мониторинг и логирование на уровне каждого микросервиса. Это позволило своевременно выявлять и устранять ошибки, что было осознанным решением, направленным на повышение надежности всей системы.