# Компромисс между возможностями и удобством

## Пример 1

В системе, отвечающий за ответственную горизонтальную логику существовала обобщенная модель "Ограничений" (generic), `interface{}` в Go. 

Для корректной работы с такой моделью каждый потребитель такого кода должен быть явно приводить модель к нужному для него типу или оперировать неоднозначной структурой - массивом словарей, значением которого выступает обобщенный тип... 

Намучавшись с приведениями и даже словив очередной баг на этом, пришла идея типизировать обобщенную модель. В Go это проще всего делается с помощью описания интерфейса с набором методов.

Было создано:

~~~go
type Constraint interface{
    GetName() string
    GetValue() int
    // ...
}
~~~

С таким интерфейсом гораздо проще стало работать, все что нужно - привести обобшенную модель к нему и уже легко, используя публичные методы, добиться нужного для себя поведения.

Текущий статус кво сохранен, система стала более понятная, а пользоваться стало удобнее.

## Пример 2

В сервисе, отвечающим за новый функционал пользователей на платном тарифе, не было простой возможности протестировать фичи платных пользователей, так как необходимо сперва оплатить тариф.

Был придуман подход с тоглом, которым задается ряд айдишников пользователей: "123;456;789", для которых система начинает считать, что пользователь приобрел платную подписку. Такой тогл был вынесен в удобную админку и его можно было менять без правок кода и коммитов в мастер. 

За счет такого удобства тестирование стало более гибким и получили возможность в случае внештатных ситуаций некоторым пользователям подключать подписку в обход стандартного флоу оплаты (уже применялась пару раз на User Day).

## Пример 3

Существующая горизонтальная библиотека для проведения АБ-экспериментов не имела публичного метода для получения контекста (в Go `context.Context`), что делало юнит-тестирование невозможным, так как контекст нужно было насыщать, но нельзя было никак проверить, что в конечном счете в нем находится после выполнения. 

Библиотека была обновлена методом, который возвращал используемый контекст и тем самым открыл возможность писать качественные юнит тесты на используемые методы.

## Пример 4

При обработке моделей и последующего сохранения их в БД была найдена особенность на тестовом окружении. Оказывается, на тестовом окружении для множества тестов генерировались заведомо невалидные мок-значения, с которыми не умела работать наша система. 

Было принято решение убрать явную валидацию, сохранять такие значения в базу, но помечать дополнительным флагом, что значение невалидное, что добавило гибкости в системе. 

## Пример 5

Когда проектировал систему ключей для Redis, то при использовании структуры HSET заметил: собираюсь сохранять множество атрибутов под одним ключом, но затем мне нужно будет как-то вычленять те атрибуты, которые имеют определенное свойство. 

На уровне Redis фильтрацию организовывать сложно (могло замедлить время ответа и создать доп. нагрузку), поэтому принял решение добавить дополнительный ключ с соответствующим признаком, под который буду сохранять нужные мне атрибуты, а не сваливать их всех в одну кучу в надежде отфильтровать это все в будущем.

Статус кво сохранен, а система стала гораздо гибче и удобнее для пользователя. 