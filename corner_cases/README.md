# Справляемся с краевыми случаями

## Краевые случаи, которые существенно усложняли код

### Логика работы с “невалидными пользователями”

В проекте с миллионами пользователей иногда попадались данные с “некорректными” атрибутами. Например, пользователь без обязательного поля email или с устаревшим идентификатором.

Эти данные ломали базовый алгоритм обработки пользователей, так как изначально предполагалось, что все данные корректны.

Но такие данные, как правило, появлялись из тестового окружения, поэтому пришлось их обрабатывать соответствующим образом.

Решение:

Создал специальные заглушки для недостающих данных: подставлял пользователям мок-значения и обозначал их, что относятся к тестовым юзерам. 

### Группа атрибутов с пользовательским параметром

Существует группа атрибутов, которые выбираются пользователем из выпадающих окон, но существут из всего множества один особый атрибут, который пользователь может ввести сам: "Пользовательский атрибут".

Решение:

Такой атрибут нужно дополнительно валидировать и обрабатывать соответственно, чтобы недопустить никаких инъекций + делать дополнительный слой модерации контента.

Поэтому было решено добавить логику, которая это поведение учитывает, но функция из-за этого серьезно раздулась как в плане кода, так и в плане тестирования.

### Разное представление для разных пользователей

У объявления на платформе есть множество представлений: карточка объявления как ее видит незарегистрированный пользователь, зарегистрированный, как ее видит продавец и т.д. 

Но недавно был обнаружен еще один кейс, который нужно было обрабатывать дополнительно: карточка объявления, которую видит продавец объявления, но который вышел на ее представление (view), как покупатель. 

Решение:

Так как за разные представления отвечать могут разные сервисы, то соответствующий корнер кейс пришлось обособлять отдельным if'ом, который поддержал бы нужную нам логику (происходила проверка на предмет того, что за пользователь и на каком представлении карточки объявления он находится, чтобы показывать нужный нам функционал), и был написать соответствующий юнит-тест, чтобы при рефакторе мы не потеряли нужную нам функциональность. 

### Источник запроса

Часто бывает, что один модуль может быть использован множеством клиентов. Имееются в виду различные интеграции: мобильные платформы, сервисы и т.д. 

Решение:

Пришлось делать карусель из switch-case, которая бы поддержала разную обработку для каждого из потребителя, так как зачастую для каждого из них необходимо делать какие-то минорные изменения из разряда: обогощать контекст каким-нибудь доп. атрибутом. 

## Как лучше обходиться с краевыми случаями

Появилась идея о явном разделении логики работы с краевыми случаями.

Как, например, для обработки исключительной ситуации мы не усложняем весь модуль или функцию, делая его более запутанным, а предоставляем отдельный слой, который обособляет такую логику и обрабатывает ее отдельно. 

Таким образом, мы не смешиваем нормальное поведение с исключительным и можем изолированно это развивать и поддерживать. 